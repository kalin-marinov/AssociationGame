@page "/counter"
@using Cloudcrate.AspNetCore.Blazor.Browser.Storage;
@using System.Threading;

@inject LocalStorage Storage
@inject Microsoft.AspNetCore.Blazor.Services.IUriHelper UriHelper


<section id="game">
    <section id="guess-screen">
        @if(roundEnded)
        {
            <div id="guess-centered">
                <p> End of round!</p>
                <button class="btn btn-primary" onclick="@StartNextRound" hidden="@(!roundEnded)" > Next </button>
            </div>
        }
        else
        {
            <div id="guess-centered">
                <p> Round @game?.CurrentRound - Fight! </p>

                <div class="menu-btn @(showPlayers ? "opened" : null)" onclick="@(() => showPlayers = !showPlayers)"> 
                    <div class="bar1"></div>
                    <div class="bar2"></div>
                    <div class="bar3"></div>
                </div>

                <h1>
                    <img style="height:40px" src="/img/user.svg" />
                     @game?.CurrentPlayer?.Name 
                </h1>
            
                @if(isWorking)
                {
                    <p class="word">
                        <span id="word-centered"> 
                             <span id="word-text"> @game.CurrentWord </span>
                        </span>
                    </p>

                    <p class="timer" > @remainingTime</p>
                }

                <div class="buttons">
                    <button class="start-btn"  onclick="@IncrementCount" hidden="@isWorking"> <img src="/img/play-button.svg" /> </button>
                    <button class="guess-btn" onclick="@DoSomething" hidden="@(!isWorking)">  <img src="/img/success.svg" /> </button>
                </div>
            </div>
        }
    </section>
    <aside id="scores" style="width:@(showPlayers ? "600px" : "0")" >
        <a class="closebtn" onclick="@(() => showPlayers = false)">&times;</a>
        <ScoreScreen Scores="@game?.GetScores()" />
    </aside>
</section>

@functions {
    bool isWorking = false;
    bool roundEnded = false;
    bool showPlayers = false;

    Game game;
    
    TimeSpan remainingTime;
    TimeSpan tickRate = TimeSpan.FromSeconds(1);

    protected override void OnInit()
    {
        var words = Storage.GetItem<string[]>("all-words");
        var players = Storage.GetItem<Player[]>("players");

        if(words == null || players == null)
            UriHelper.NavigateTo("/words");

        else game = new Game(words, players);
    }


    async Task IncrementCount()
    {
        isWorking = true;
        roundEnded = false;

        remainingTime = game.TurnTime;
        var playerTurn = game.PlayTurn();
        await ResizeWord();

        while(remainingTime.TotalMilliseconds > 0 && !roundEnded)
        {
            await Task.Delay(tickRate);
            remainingTime = remainingTime.Subtract(tickRate);
            this.StateHasChanged();
        }

        await playerTurn;
        isWorking = false;
        this.StateHasChanged();
    }

    async Task DoSomething()
    {
        if(remainingTime.TotalSeconds < 1)
            return;

        game.GuessWord();
    
        if(game.CurrentWord == null){
            Console.WriteLine("End of round");
            roundEnded = true;
        }
        
        await Sounds.Success();
    }

    void StartNextRound()
    {
        game.FinishRound();
        roundEnded = false;
        remainingTime = game.TurnTime;
    }


 //   protected override Task OnAfterRenderAsync(){
 //       return ResizeWord();
 //   }

    Task ResizeWord()
    {
        return JSRuntime.Current.InvokeAsync<bool>("deferFit", "#word-text");
    }
}
